-- 1. TABELLE
-- Tabella per i codici admin (semplificata)
CREATE TABLE public.admins (
  code text PRIMARY KEY NOT NULL
);

-- Tabella delle serate
CREATE TABLE public.nights (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  name text NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  is_open boolean DEFAULT false NOT NULL
);

-- Tabella dei partecipanti (artisti)
CREATE TABLE public.participants (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  full_name text UNIQUE NOT NULL
);

-- Tabella dei voti (lega utente e serata)
CREATE TABLE public.votes (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  night_id uuid REFERENCES public.nights(id) ON DELETE CASCADE NOT NULL,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  UNIQUE (night_id, user_id) -- Vincolo chiave: un utente vota una volta per serata
);

-- Tabella delle scelte di voto (lega voto e artista)
CREATE TABLE public.vote_choices (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  vote_id uuid REFERENCES public.votes(id) ON DELETE CASCADE NOT NULL,
  participant_id uuid REFERENCES public.participants(id) ON DELETE CASCADE NOT NULL,
  rank int NOT NULL CHECK (rank >= 1 AND rank <= 3), -- Non usato per punteggio, ma per struttura
  UNIQUE (vote_id, participant_id), -- Vincolo: non puoi votare lo stesso artista due volte nello stesso voto
  UNIQUE (vote_id, rank) -- Vincolo: ogni preferenza (1, 2, 3) è unica
);

-- 2. ABILITAZIONE ROW LEVEL SECURITY (RLS)
ALTER TABLE public.admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.nights ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vote_choices ENABLE ROW LEVEL SECURITY;

-- 3. POLITICHE RLS (Regole di accesso)
-- Admin: possono fare tutto (assumendo che un giorno si usi un ruolo admin)
-- Per ora, le modifiche admin si basano sulla validità del codice, non su un ruolo utente.
-- L'accesso è garantito a livello di codice applicativo.
-- Rendiamo le letture pubbliche dove serve e le scritture protette.

-- Chiunque può leggere serate e partecipanti
CREATE POLICY "Allow public read access to nights" ON public.nights FOR SELECT USING (true);
CREATE POLICY "Allow public read access to participants" ON public.participants FOR SELECT USING (true);

-- Gli utenti autenticati possono inserire il proprio voto
CREATE POLICY "Allow authenticated users to insert their own vote" ON public.votes FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Gli utenti possono leggere solo i propri voti
CREATE POLICY "Allow users to read their own votes" ON public.votes FOR SELECT USING (auth.uid() = user_id);

-- Gli utenti possono inserire le proprie scelte di voto
CREATE POLICY "Allow users to insert their own vote choices" ON public.vote_choices FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.votes
    WHERE votes.id = vote_choices.vote_id AND votes.user_id = auth.uid()
  )
);

-- Politiche Admin: gli admin possono gestire tutto. Senza service_key, queste policy non si attivano
-- ma le lasciamo per completezza. La logica admin si basa sull'accesso tramite codice.
CREATE POLICY "Allow admin full access to admins" ON public.admins USING (true) WITH CHECK (true);
CREATE POLICY "Allow admin full access to nights" ON public.nights USING (true) WITH CHECK (true);
CREATE POLICY "Allow admin full access to participants" ON public.participants USING (true) WITH CHECK (true);
CREATE POLICY "Allow admin read access to votes" ON public.votes FOR SELECT USING (true);
CREATE POLICY "Allow admin read access to vote choices" ON public.vote_choices FOR SELECT USING (true);


-- 4. FUNZIONI DATABASE (RPC)

-- Funzione per aprire una serata e chiudere tutte le altre (transazionale)
CREATE OR REPLACE FUNCTION open_night(night_id_to_open uuid)
RETURNS void AS $$
BEGIN
  -- Chiudi tutte le serate
  UPDATE public.nights SET is_open = false WHERE is_open = true;
  -- Apri la serata specificata
  UPDATE public.nights SET is_open = true WHERE id = night_id_to_open;
END;
$$ LANGUAGE plpgsql;

-- Funzione per ottenere il conteggio dei voti
CREATE OR REPLACE FUNCTION get_vote_counts()
RETURNS TABLE(night_name text, participant_name text, vote_count bigint) AS $$
BEGIN
  RETURN QUERY
  SELECT
    n.name AS night_name,
    p.full_name AS participant_name,
    COUNT(vc.id) AS vote_count
  FROM
    public.vote_choices vc
    JOIN public.votes v ON vc.vote_id = v.id
    JOIN public.participants p ON vc.participant_id = p.id
    JOIN public.nights n ON v.night_id = n.id
  GROUP BY
    n.name,
    p.full_name
  ORDER BY
    n.name,
    vote_count DESC;
END;
$$ LANGUAGE plpgsql;

-- 5. DATI INIZIALI (SEED)

-- Inserisci un codice admin (cambialo con uno a tua scelta!)
INSERT INTO public.admins (code) VALUES ('FestivalAdmin2025!');

-- Inserisci alcuni artisti di esempio
INSERT INTO public.participants (full_name) VALUES
  ('The Midnight Bloom'),
  ('Solar Flare'),
  ('Echo Collective'),
  ('Crimson Tide'),
  ('Lunar Echoes'),
  ('Starlight Brigade'),
  ('Neon Prophets'),
  ('Golden Haze');